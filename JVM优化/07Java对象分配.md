## TLAB
TLAB全称是一个Thread Local Allocation Buffer，即线程本地分配缓存，这是一个线程专用的内存分配区域。由于对象一般会分配到堆上，而堆是全局共享的，因此同一时间可能会有多个线程在堆上申请空间，因此每次对象分配都必须进行同步，而在竞争激烈的场合分配的效率又会进一步下降。JVM使用TLAB来避免多线程冲突，在给对象分配内存时，每个线程使用自己的TLAB，这样可以避免线程同步，提高了对象分配的效率。 

**TLAB本身占用eEden区空间**，在开启TLAB的情况下，虚拟机会为每个Java线程分配一块TLAB空间。参数-XX:+UseTLAB开启TLAB，默认是开启的。TLAB空间的内存非常小，缺省情况下仅占有整个Eden空间的1%，当然可以通过选项-XX:TLABWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小。

由于TLAB空间一般不会很大，因此大对象无法在TLAB上进行分配，总是会直接分配在堆上。TLAB空间由于比较小，因此很容易装满。比如，一个100K的空间，已经使用了80KB，当需要再分配一个30KB的对象时，肯定就无能为力了。这时虚拟机会有两种选择，第一，废弃当前TLAB，这样就会浪费20KB空间；第二，将这30KB的对象直接分配在堆上，保留当前的TLAB，这样可以希望将来有小于20KB的对象分配请求可以直接使用这块空间。实际上虚拟机内部会维护一个叫作**refill_waste**的值，当请求对象大于refill_waste时，会选择在堆中分配；若小于该值，则会废弃当前TLAB，新建TLAB来分配对象。这个阈值可以使用TLABRefillWasteFraction来调整，它表示TLAB中允许产生这种浪费的比例。默认值为64，即表示使用约为1/64的TLAB空间作为refill_waste。

默认情况下，TLAB和refill_waste都会**在运行时不断调整的**，使系统的运行状态达到最优。如果想要禁用自动调整TLAB的大小，可以使用-XX:-ResizeTLAB禁用ResizeTLAB，并使用-XX:TLABSize手工指定一个TLAB的大小。 


## Java对象分配的过程
虚拟机的PretenureSizeThreshold参数表示如果对象大于该值，就直接分配到老年代，但是TLAB的优先级大于该参数，也就是说，如果一个对象的大小大于该参数规定的大小，但是却可以在TLAB中放下，虚拟机会优先放入TLAB中，而不是放入老年代中。
1. 编译器**通过逃逸分析，确定对象是在栈上分配还是在堆上分配**。如果是在堆上分配，则进入选项2

2. 如果tlab_top + size <= tlab_end，则在在TLAB上直接分配对象并增加tlab_top 的值，如果现有的TLAB不足以存放当前对象则3
3. 重新申请一个TLAB，并再次尝试存放当前对象。如果放不下，则4
4. Eden区分配：（如果满足了PretenureSizeThreshold的条件，直接放入老年代）。在Eden区加锁（这个区是多线程共享的），如果eden_top + size <= eden_end则将对象存放在Eden区，增加eden_top 的值，如果Eden区不足以存放，则5
5. 执行一次Young GC（minor collection）
6. 经过Young GC之后，如果Eden区任然不足以存放当前对象，则直接分配到老年代。



## Java类对象在jvm中的位置
从内存的角度来看：
* 方法区：存放类的信息和常量。
* Java栈：只存放局部变量。
* 堆：存放对象实例的信息。

从变量的角度来看：
* 局部变量：存放在Java栈中。基本类型直接存储在栈中，对象类型只存放对象的引用。
* 静态变量：存放在方法区中，如果是对象类型的常量，那么只存放该对象的引用。
* 实例变量：存放在堆中的对象实例中。

从上面变量的角度就可以分析出为什么静态变量不需要实例化就可以调用。