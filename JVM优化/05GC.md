# GC简介
垃圾回收，Garbage Collection，简称GC，GC中的垃圾，指的是存在于内存中，不会再使用的对象。垃圾回收有很多算法，如引用计数法，标记压缩法，复制算法，分代、分区的思想：
* 引用计数法：给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，计数器-1，当计数器为0的时候JVM就认为这个对象不再使用，就是垃圾了。引用计数法的缺点是不能解决循环引用的问题。
* 标记清除法：分为标记和清除两个阶段进行处理内存中的对象，这种方式也有较大的弊端，就是会带来空间碎片的问题。

* **复制算法**：核心思想就是将内存空间分为两块，每次只使用一块，当这一块用完了就将还存活的对象复制到另一块上面，然后把已经用过的内存空间清理掉，这样使得每次都是堆整个半区进行内存回收。新生代中的from和to空间就是使用的这个算法。
* **标记压缩法**：标记压缩法在标记清除法上做了优化，把存活的对象压缩到内存一端，完成垃圾收集。老年代就是使用的这个算法。
* **分代算法**：当前的虚拟机都是采用分代算法。他根据对象的存活周期不同将内存划分为几块，一般是把Java堆划分为新生代和老年代，然后根据各个部分的特点采用不同的收集算法。由于新生代中每次垃圾收集都有大量的对象死去，所以使用的是复制算法，老年代中对象存活率高，每次只有少数的对z象需要清除，所以使用的就是标记压缩法。

## 垃圾的标记
对一些已经不再使用的对象打上标记，方便垃圾收集器的清理。一般有两种标记算法，引用计数法和可达性分析。

**引用计数法**：给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，计数器-1，当计数器为0的时候JVM就认为这个对象不再使用，就是垃圾了。引用计数法的缺点是**不能解决循环引用的问题**。

## 可达性分析
可达性分析的基本思路就是：通过将一些称为"GC Roots"的对象作为起始点，从这些节点开始搜索，搜索和该节点**发生直接或者间接引用关系的对象**，将这些对象以链的形式组合起来，形成一张“关系网”，又叫做引用链。最后垃圾收集器就回收一些不在这张关系网上的对象。在Java中，可以作为GC Roots的对象有以下几种：
* 栈帧中引用的对象（栈中）
* 类静态属性引用的对象（方法区中）
* 常量引用的对象（方法区中）
* JNI（即一般说的Native方法）引用的对象（本地方法栈中）
### 对象的二次回收
即使可达性分析中不可达的对象，也不是一定要被清除的，这时候他们暂时处于缓刑阶段，要真正宣告一个对象的死亡，至少要经历再次标记的过程。标记的**前提是对象在可达性分析之后没有发现和GC Roots相连接的引用链**。
* **第一次标记**：筛选的条件是对象**是否有必要执行finalize()方法**，当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，对象被回收。
* 第二次标记：即当一个对象重写了finalize（）方法的时候，这个对象被判定为有必要执行finalize（）方法，那么这个对象被放置在F-Queue队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的执行是指虚拟机会出发这个方法，但不承诺会等待它运行结束。这样做的原因：如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（极端的情况下），将可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize（）方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize（）中成功拯救自己----只要重新与引用链上的任何建立关联即可，那么在第二次标记时它将会被移出“即将回收”的集合；如果对象这时候没有逃脱，就会被回收。

# GC的分类
针对HorSpot JVM中的实现，GC分为两大类：
* Partial GC(局部GC)：不收集整个GC堆的模式
    * Young GC：只收集新生代的GC，也叫**Minor GC**
    * Old GC：只收集老年代的GC，只有垃圾收集器CMS的concurrent collection是这个模式
    * Mixed GC：收集整个新生代和部分老年代的GC，只有垃圾回收器G1有这个模式。
* Full GC：收集整个堆，包括新生代，老年代，**永久代**（**JDK1.8以后，永久代被移除，换为metaspace元空间，不存在堆中**）等所有部分的模式。**Major GC**通常是跟full GC是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是old GC。

## Full GC
针对不同的垃圾收集器，Full GC的触发条件可能不一样。按HotSpot VM的Serial GC的实现来看，触发条件是：
* 当准备触发一次Minor GC时，如果发现统计数据说之前Minor GC的平均晋升大小比目前的Old Gen剩余的空间大，则不会出发Minor GC而是转为触发Full GC(因为HotSpot VM的GC里，除了垃圾回收器 CMS的concurrent collection 之外，其他能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先准备一次单独的Minor GC)。
* 如果有永久代，只要永久代分配空间但没有足够的空间时，也要触发一次Full GC。

## Minor GC
Minor GC是俗称，新生代的垃圾收集就叫做Minor GC，Minor GC非常频繁，且回收速度也比较快。其触发条件是：新生代Eden区满的时候触发一次Minor GC。过程：<br>
当发生MinorGC时，Eden区和from指向的Survivor区中的存活对象会被复制（此处采用的是标记-复制算法）到to指向的Survivor区，然后交换from和to指针，以保证下一次MinorGC时，to指向的Surivor区还是空的。**注:from和to只是两个指针，他们是变动的，to指针指向的Survivor区是空的。**


# PrintGCDetails  UseSerialGC
串行垃圾回收器的日志，其中第一个清理的是年轻代，第二个清理的是整个堆内存。
```
[GC (Allocation Failure) [DefNew: 1526K->192K(1856K), 0.0034542 secs] 1526K->611K(5952K), 0.0035392 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

[GC (Allocation Failure) [DefNew: 1265K->0K(1856K), 0.0014649 secs][Tenured: 1614K->1615K(4096K), 0.0029793 secs] 1684K->1615K(5952K), [Metaspace: 3127K->3127K(1056768K)], 0.0045316 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] 
```
年轻代GC解析：
* GC：**标志位，区分Minor GC还是Full GC**，这里GC表示本次发生的是Minor GC

* (Allocation Failure)：**引起垃圾回收的原因**，这里表示本次GC是因为年轻代中没有足够的空间
* [DefNew: 1526K->192K(1856K), 0.0034542 secs]：
    * DefNew：垃圾收集器的名字，DefNew代表单线程、采用标记复制算法、使整个JVM暂停运行的年轻代垃圾收集器
    * 1526K->192K(1856K)：本次垃圾回收之前和之后的使用状况，括号中是年轻代总的大小
    * 0.0034542 secs：此次垃圾收集耗费的时间，单位是秒
* 1526K->611K(5952K), 0.0035392 secs：垃圾回收之前和之后**整个堆的使用状况**和耗费的时间
* [Times: user=0.00 sys=0.00, real=0.00 secs]：GC时间的持续时间，通过多种方式来衡量：
    * user：此次垃圾回收，垃圾收集线程消耗的所有CPU时间
    * sys：操作系统调用以及等待系统事件的时间
    * real：应用程序暂停的时间(Clock time)。由于串行垃圾收集器(Serial Garbage Collector)只会使用单个线程，所以real time等于user以及system time的总和。