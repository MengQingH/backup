# Java虚拟机的组成
JVM主要由**类加载子系统、运行时数据区（内存空间）、执行引擎和本地方法结构**组成，其中运行时数据区又由**方法区、堆、Java栈、PC寄存器、本地方法栈**组成。在内存空间中**方法区和堆是所有Java线程共享的**，而**Java栈、本地方法栈、PC寄存器则由每个线程私有**。
<br><img src=img/JVM组成.png><br>

# 类加载子系统(Class Loader)
类加载器子系统负责**加载编译好的.class字节码文件**，并装入内存，使JVM可以实例化或以其它方式使用加载后的类。JVM的类加载子系统支持在运行时的**动态加载**，动态加载的优点有很多，例如可以节省内存空间、灵活地从网络上加载类，动态加载的另一好处是可以通过命名空间的分隔来实现类的隔离，增强了整个系统的安全性。

## ClassLoader的分类
* 启动类加载器（BootStrap Class Loader）：负责加载rt.jar文件中所有的Java类，即**Java的核心类**都是由该ClassLoader加载。在Sun JDK中，这个类加载器是**由C++实现**的，并且在Java语言中无法获得它的引用。

* 扩展类加载器（Extension Class Loader）：负责加载一些**扩展功能的jar包**。
* 系统类加载器（System Class Loader）：负责**加载启动参数中指定的Classpath中的jar包及目录**，通常我们**自己写的Java类也是由该ClassLoader加载**。在Sun JDK中，系统类加载器的名字叫AppClassLoader。
* 用户自定义类加载器（User Defined Class Loader）：由用户自定义类的加载规则，可以手动控制加载过程中的步骤。

## ClassLoader的工作原理
类加载分为三步：装载、链接、初始化。
### 1. **装载**
通过类的全限定名和ClassLoader加载类，主要是将指定的.class文件加载至JVM。当类被加载以后，在JVM内部就以“类的全限定名+ClassLoader实例ID”来标明类。

在内存中，ClassLoader实例和类的实例都位于堆中，它们的类信息都位于方法区。

装载过程采用了一种被称为“双亲委派模型（Parent Delegation Model）”的方式，当一个ClassLoader要加载类时，它会先请求它的双亲ClassLoader（其实这里只有两个ClassLoader，所以称为父ClassLoader可能更容易理解）加载类，而它的双亲ClassLoader会继续把加载请求提交再上一级的ClassLoader，直到启动类加载器。只有其双亲ClassLoader无法加载指定的类时，它才会自己加载类。

双亲加载模型的**优点**：虚拟机只有在两个类的类名相同且加载该类的加载器均相同的情况下才判定这是一个类。若不采用双亲委派机制，同一个类有可能被多个类加载器加载，这样该类会被识别为两个不同的类，相互赋值时会有问题。双亲委派机制能保证多加载器加载某个类时，最终都是由一个加载器加载，确保最终加载结果相同。

双亲委派模型是JVM的第一道安全防线，它保证了类的安全加载，这里同时依赖了类加载器隔离的原理：不同类加载器加载的类之间是无法直接交互的，即使是同一个类，被不同的ClassLoader加载，它们也无法感知到彼此的存在。这样即使有恶意的类冒充自己在核心包（例如java.lang）下，由于它无法被启动类加载器加载，也造成不了危害。
由此也可见，如果用户自定义了类加载器，那就必须自己保障类加载过程中的安全。
### 2. **链接**
链接的任务是把二进制的类型信息合并到JVM运行时状态中去。
### 3. **初始化**
初始化类中的静态变量，并执行类中的static代码、构造函数。JVM规范定义了何时需要对类进行初始化：
* 通过new关键字、反射、clone、反序列化机制实例化对象时。
* 调用类的静态方法时。
* 使用类的静态字段或对其赋值时。
* 通过反射调用类的方法时。
* 初始化该类的子类时（初始化子类前其父类必须已经被初始化）。
* JVM启动时被标记为启动类的类（简单理解为具有main方法的类）。

# 运行时数据区
## Java栈(Java Stack)
Java栈的主要任务是**存储方法参数、局部变量、中间运算结果**，并且提供部分其他模块工作需要的数据。

Java栈总是和线程关联在一起的，每当**创建一个线程时，JVM就会为该线程创建相应的Java栈**，在这个Java栈中又**包含多个栈帧**(Stack Frame)，这些栈帧是与每个方法关联起来的，**每运行一个方法就创建一个栈帧**，每个栈帧中会含有一些局部变量、操作栈和方法返回值等信息。每当一个方法执行完成时，该栈帧就会**弹出栈帧的元素作为这个方法的返回值**，并且清除这个栈帧，Java栈的栈顶的栈帧就是当前正在执行的活动栈，也就是当前正在执行的方法，PC寄存器也会指向该地址。只有这个活动的栈帧的本地变量可以被操作栈使用，当在这个栈帧中调用另外一个方法时，与之对应的一个新的栈帧被创建，这个新创建的栈帧被放到Java栈的栈顶，变为当前的活动栈。同样现在只有这个栈的本地变量才能被使用，当这个栈帧中所有指令都完成时，这个栈帧被移除Java栈，刚才的那个栈帧变为活动栈帧，前面栈帧的返回值变为这个栈帧的操作栈的一个操作数。

由于Java栈是与线程对应起来的，Java栈数据不是线程共有的，所以不需要关心其数据一致性，也不会存在同步锁的问题。

分为三个部分：局部变量区、操作数栈、帧数据区。
### **局部变量区**
局部变量区是以字长为单位的数组，在这里，byte、short、char类型会被转换成int类型存储，除了long和double类型占两个字长以外，其余类型都只占用一个字长。特别地，boolean类型在编译时会被转换成int或byte类型，boolean数组会被当做byte类型数组来处理。局部变量区也会包含对象的引用，包括类引用、接口引用以及数组引用。

局部变量区包含了方法参数和局部变量，此外，实例方法隐含第一个局部变量this，它指向调用该方法的对象引用。对于对象，局部变量区中永远只有指向堆的引用。
### **操作数栈**
操作数栈也是以字长为单位的数组，但是他只能进行入栈出栈的基本操作，主要保存计算过程的中间结果。在进行计算时，操作数被弹出栈，计算完毕后再入栈。
### **帧数据区**
帧数据区的任务主要有：
* 记录指向类的常量池的指针，以便于解析。
* 帮助方法的正常返回，包括恢复调用该方法的栈帧，设置PC寄存器指向调用方法对应的下一条指令，把返回值压入调用栈帧的操作数栈中。
* 记录异常表，发生异常时将控制权交由对应异常的catch子句，如果没有找到对应的catch子句，会恢复调用方法的栈帧并重新抛出异常。

局部变量区和操作数栈的大小依照具体方法在编译时就已经确定。调用方法时会从方法区中找到对应类的类型信息，从中得到具体方法的局部变量区和操作数栈的大小，依此分配栈帧内存，压入Java栈。

在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

## 方法区(Method Area)
又称为永久区(Perm)。存放**类的信息**，包括类及父类的全限定名、访问修饰符、实现接口的列表、字段和方法的信息、**静态变量**、**常量、常量池**等。<br/>
类的所有信息都是存在于方法区中的，由于方法区是所有线程共享的，所以必须保证线程安全。方法区逻辑上属于堆，但是为了和堆进行区分，通常又叫做 非堆。
### **永久代**
**方法区又称永久区，Perm**，是JVM规范中的定义的一个概念，用于存储类信息、常量池等数据，具体放在哪里，不同的实现可以放在不同的地方。而**永久代（PermGen）是只在Hotspot虚拟机中存在的概念，是方法区的一种实现**，在Hotspot的实现中属于堆内存，别的JVM中没有这个东西，在jdk1.8之前存在。1.8之后，永久代被移除，取而代之的是一块**与堆不相连的本地内存——元空间（Metaspace）**。元空间本质上和永久代类似，都是堆JVM规范中方法区的实现，不过不同时元空间并不存在于虚拟机中，而是使用本地内存。

### **常量池**
常量池本身是一个数据结构。常量池中存储了如**字符串、final变量、类名和方法名常量**。常量池**在编译期间就被确定**，并**保存在已编译的.class文件中**。一般分为两类：**字面量和引用量**。字面量就是字符串、final变量等。类名和方法名属于引用量。引用量最常见的就是在调用方法的时候，根据方法名找到方法的引用，并以此定位到函数体进行函数代码的执行。引用量包含：类和接口的权限定名、字段的名称和描述符，方法的名称和描述符。

## 堆(Heap)
堆是JVM所管理的内存中最大的一块，是**被所有Java线程锁共享的**，不是线程安全的，**在JVM启动时创建**。

堆用于存储对象实例以及数组值，堆是存储Java对象的地方，这一点Java虚拟机中的描述是：所有的对象实例以及数组都要在堆上分配。堆中有指向类数据的指针，该指针指向了方法区中对应的类型信息。堆中还可能存放了指向方法表的指针。堆是所有线程共享的，所以在进行实例化对象等操作时，需要解决同步问题。此外，堆中的实例数据中还包含了对象锁，并且针对不同的垃圾收集策略，可能存放了引用计数或清扫标记等数据。

### 堆的分代管理：
根据垃圾回收机制的不同，Java堆中可能拥有不同的结构。最为常见的是将整个Java堆分为**新生代和老年代**，其中默认大小的比例为1：2。其中新生代存放新生的对象或者年龄不大的对象，老年代则存放老对象。大多数情况下，对象首先被分配在eden区，在一次新生代回收后，如果对象还活着，则会进入s0**或**s1区，之后每经过一次新生代回收，如果对象存活则他的年龄就加1，当对象达到一定的年龄之后就进入老年代，默认15次。
1. 新生代(Young Generation)：主要存储新创建的对象和尚未进入老年代的对象，大多数情况下新对象都被分配在新生代中，新生代由Eden Space，后两块。新生代又分为eden区(Eden Space)和两块大小相同的Survivor Space(s0区、s1区)组成，这三块空间大小比例位8:1:1。s0和s1又被称为from和to区域，是两块**大小相等**并且**可以互换角色**的空间，主要是用于Minor GC时的对象复制。
2. 老年代(Old/Tenuring Generation)：新生代中存活时间比较长的对象会被转入老年代，老年代进行垃圾收集的频率没有新生代高。
<br><img src=img/Heap.png><br>

## 本地方法栈(Native Method Stack)
本地方法栈类似于Java栈，主要存储了本地方法调用的状态。区别是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行本地方法服务。本地方法栈中会抛出StackOverflowError和OutOfMemoryError异常。

## PC寄存器(Program Count Register)
是一个数据结构，用来**保存当前正在执行的程序的内存地址**，由于Java是支持多线程执行的，所以程序执行的轨迹不可能一直都是线性执行。当有多个线程交叉执行时，被中断的线程的程序当前执行到哪条内存地址必然要保存下来，以便用于被中断的线程恢复执行时再按照被中断时的指令地址继续执行下去。为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存，这在某种程度上有点类似于“ThreadLocal”，是线程安全的。


# 执行引擎
执行引擎是JVM执行Java字节码的核心，负责执行虚拟机的字节码，一般是先进行编译成机器码后执行。执行方式主要分为解释执行、编译执行、自适应优化执行、硬件芯片执行方式。

JVM的指令集是基于栈而非寄存器的，这样做的好处在于可以使指令集尽可能的紧凑，便于快速的在网络上传输，同时也很容易使用通用寄存器较少的平台，并且有利于代码优化，由于Java栈和PC寄存器的线程是私有的，线程之间无法相互干涉彼此的栈，每个线程拥有独立的JVM执行引擎实例。

JVM指令由单字节操作码和若干操作数组成。对于需要操作数的指令，通常是先把操作数压入操作数栈，即使是对局部变量赋值，也会先入栈再赋值。


# 堆、栈、方法区
堆解决的是**数据存储的问题**，即数据怎么放、放在哪。<br>
栈解决的是**程序的运行问题**，即程序如何执行，或者说如何处理数据。<br>
方法区则是辅助堆栈的一块永久区，解决**堆栈信息的产生**，是先决条件。<br>
在JVM中新建一个对象的过程：类的信息放在方法区中，从方法区取出类的模板进行初始化，初始化之后的对象放在堆中，对象的引用放在栈中。