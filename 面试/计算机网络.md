## Http和Https的区别
Http协议运行于TCP之上，明文传输，客户端和服务器端都无法验证对方的身份；
Https是身披SSL外壳的Http，运行于SSL之上，是添加了加密和认证机制的Http。二者不同如下：
* 端口不同：Http和Https使用不同的连接方式，用的端口也不一样，前者是80，后者是443.
* 资源消耗：和Http相比，Https通信会由于加减密处理消耗更多的CPU和内存资源。
* 开销：Https需要证书。

## TCP的三次握手和四次挥手

* SYN：同步序列编号（ynchronize Sequence Numbers）。表示创建一个连接。
* ACK：Acknowledgement，确认字符，确认收到的数据。
* FIN：终结一个连接。
### 三次握手
* 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
* 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
* 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。
<br><img src=img/三次握手.png>
### 四次挥手
* 第一次挥手：Client发送一个FIN，**用来关闭Client到Server的数据传送**，Client进入FIN_WAIT_1状态。
* 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
* 三次挥手：Server发送一个FIN，**用来关闭Server到Client的数据传送**，Server进入LAST_ACK状态。
* 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。
<br><img src=img/四次挥手.png>

## TCP保证传输的可靠性
TCP是一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户端一个服务端）在彼此交换数据之前必须先建立一个TCP连接。在一个TPC连接中，仅有两方进行彼此通信，而字节流意味着两个应用程序通过TCP连接交换8比特的字节流，TCP不在字节流中插入记录标识符。对于可靠性，TCP通过以下方式保证：
* 数据包校验：目的是检测数据在传输过程中的变化，若校验包出错，则丢弃报文并且不给出相应，这时TCP发送数据端超时后会重发数据。
* 对失序数据包重新排序：TCP对失序的数据包重新进行排序，然后再交给应用层。
* 丢失重复数据：对于重复数据，能够丢弃重复数据。
* 应答机制：当TCP收到发自另一端的数据，它将发送一个确认，这个确认不是立即发送，而是延迟几秒。
* 超时重发：当TCP发出一个段后，它启动一个定时器，等待目的段收到这个报文段。如果不能即使收到一个确认，将重发这个报文段。
* 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。使用的协议就是可变大小的滑动窗口协议。

## TCP进行三次握手的原因
为了防止已失效的链接请求报文突然又传送到服务端，因而产生错误。<br>
如果客户端发出的链接请求并未丢失，而是在某个网络结点滞留了，以致**延误到链接释放以后的某个时间才达到Server**，Server收到请求就向客户端发送确认数据包，同意建立连接。此时，如果不采用三次连接，那么只要Server发送确认数据包，新的连接就建立了。由于Clent此时并未发出建立简介的请求，所以不理睬Server的连接，也不会和Server通信，而这时Server一直等待Client的请求，这样Server就白白浪费了一定的资源。若采用三次握手，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要建立连接请求，就不会建立连接。

## HTTP请求类型
post, get, put, delete, trace, head, options, connect;

## HTTP的版本
* 0.9：原始版本，只有get操作
* 1.0：增加了post、head操作，增加了状态码
* 1.1：增加了持久连接，全二进制，管道，put、delete、optioons等请求方式。
* 2.0：增加了双工，数据流

## Get和Post的区别
1. 从功能上来讲，get一般用来从服务器上获取某个资源，post一般用来更新某个资源。
2. 请求参数上，get请求的数据会附在URL之后，即将请求数据放在HTTP报文的请求头中，以？分割URL和传输数据，参数之间以&相连。而post请求会把提交的数据放在HTTP报文的请求体中。
3. 安全性上来说，post比get高。
4. 请求的大小来看，get请求的长度受限于浏览器或服务器对url的长度的限制，而post请求则是没有请求大小的限制的。

## TCP和UDP的区别
* TCP是面向连接的，UDP是无连接的。
* TCP是可靠的，UDP是不可靠的。
* TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式。
* TCP是面向字节流的，UDP是面向报文的。
* TCP有拥塞控制机制，UDP没有拥塞控制。
* TCP首部开销（20)比UDP大（8）。

## 从输入网址到获得页面的过程
1. 浏览器查询DNS，获取域名对应的IP地址：具体过程包括浏览器搜索自身的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。
    * 向本地DNS服务器进行查询：如果要查询的域名包含在本地设置区域资源中，则返回解析结果给客户机，完成域名解析；
    * 如果查询的域名不在本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析；
    * 如果本地域名服务器中并未缓存该网址的映射关系，那么将根据其设置发起递归查询或者迭代查询。
2. 浏览器获得对应域名对应IP地址后，向服务器请求建立连接，发起三次握手。
3. TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求。
4. 服务器收到这个请求，并根据路径参数映射到特定的请求处理器进行引用，并将处理结果发送给浏览器。
5. 浏览器解析并渲染视图，若遇到对js文件、css文件等静态资源的引用，则重复上述步骤并向服务器请求这些资源。
6. 浏览器根据请求的资源、数据渲染页面，最终向用户呈现一个完整的页面。


## session、cookie、application
sesion和cookie都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session是在服务器端保持状态的方案。
1. Cookie：Cookie实际上是一段文本信息，保存在浏览器中。
    * 客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，而客户端浏览器会把Cookie保存起来。
    * 当浏览器再次访问该网站时，就会把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。
2. Session：会话信息保存在服务器端。
    * 客户端请求浏览器，如果服务器记录该用户状态，就获取Session来保存状态。这时如果客户端已经为此客户端创建过session，服务器就会按照sessionId把这个session检索出来；如果客户端请求不包含sessionId，则为此客户端创建一个session，并生成一个与此session相关联的sessionId，并将这个sessionID在本次响应中返回客户端保存。
    * 保存这个sessionId的方式可以采用**Cookie机制**，这样在交互的过程中浏览器可以自动的按照规则把这个标识发送给服务器；若浏览器禁用了Cookie，那么可以通过**URL重写机制**将sessionId传回服务器。
3. Application：一个全局的域对象，和一个web程序相对应，所有的客户端都可以使用该对象。

## OSI网络体系和TCP/IP协议模型
OSI是一个理论上的通信模型，而TCP/IP则是实际的网络通信标准。
<br><img src=img/osi.png><br>
OSI七层模型：
1. 物理层：实现了相邻计算机节点之间的比特流的透明传输，并尽可能的屏蔽掉具体传输介质和物理设备上的差异，使其上层（数据链路层）不必关心网络的具体传输介质。
2. 数据链路层：接收来自物理层的位流形式的数据，并封装成帧，送到上一层；同样，也将来自上层的数据帧拆分成位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错传输、流量控制等方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输的方法。
3. 网络层：将网络地址翻译成对用的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。
4. 传输层：在源端和目的端之间提供可靠的透明数据传输，使上层服务用户不必关心通信子网的实现细节。在协议栈中，传输层位于网络层之上，传输层协议为不同的主机上运行的进程提供逻辑通信，而网络层协议为不同的主机提供的逻辑通信。
5. 会话层：是应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信。
6. 表示层：数据的编码、压缩和解压缩，数据的加密和解密。
7. 应用层：为用户的应用进程提供网络通信服务。

## 常见状态码
* 1**：请求处理中，请求已被接受，正在处理。
* 2**：请求成功，请求已被成功处理。
    * 200：OK
* 3**：重定向，请求要完成必须进一步的处理
    * 301：永久性转移
    * 302：暂时性转移
    * 304：已缓存
* 4**：客户端错误，请求不合法
    * 400：请求有语法问题
    * 403：拒绝请求
    * 404：客户端所访问的页面不存在
* 5**：服务器端有错误，服务器不能处理合法请求
    * 500：服务器内部错误
    * 503：服务器不可用，稍等
