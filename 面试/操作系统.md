## 进程和线程以及他们的区别
* 进程：是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发。
* 线程：是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现了进程内部的并发。

## 进程间通信的几种方式
* 管道及命名管道：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道具有的功能外，他还允许无亲缘关系进程间的通信。

* 信号：信号是一种比较复杂的通信方式，用于通知接受进程某个事件已经发生。
* 消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限的进程可以按照一定的规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；
* 共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；
* 信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；
* 套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。

## 死锁及产生条件
### 死锁
如果一组进程中的每一个进程都在等待由该组其他进程才能引发的事件，那么称该组进程是死锁的。
### 必要条件
* 互斥条件：进程对所分配到的资源进行排他性使用，即一段时间内只能被一个进程使用；若其他进程申请使用该资源，那么申请进程必须等到该资源被释放为止；

* 请求和保持条件：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；
* 不可抢占条件：进程不能被抢占，即资源只能被进程在完成任务后自己释放；
* 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系

### 预防

## 进程的状态
* 就绪状态：进程已获得除处理机以外的所需的资源，等待分配处理机资源。
* 运行状态：占用处理机资源，处于此状态的进程数小于等于CPU数。
* 阻塞状态：进程等待某种条件，在条件满足之前无法执行。

## 线程的状态
* 新建状态（New）：新创建了一个线程对象。
* 等待状态（）：线程新建之后直到调用.start方法之前，

* 就绪状态（Runnable）：也叫可运行状态。线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
* 运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
* 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
    * ①等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。
    * ②同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
    * ③其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
* 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

## 线程方法
* 线程睡眠：Thread.sleep(long mile);使线程转到阻塞状态，持续mile毫秒，睡眠结束后，转为就绪状态。
* 线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()唤醒方法。这个两个唤醒方法也是Object类中的方法.
* 线程让步：Thread.yield()方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。
* 线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。
* 线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。

## 操作系统进程调度策略
* FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU
* SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度
* 优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化
* 时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。
* 多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。
* 多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。

## 页面置换算法
* FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；
* LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断；
* LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；
* OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。

## 用户态 核心态
### 操作系统需要两种CPU状态：
* 用户态：运行用户程序。
* 核心态：运行操作系统程序。

### 指令划分：
* 特权指令：只能由操作系统使用、用户程序不能使用的指令。举例：启动I/O   内存清零
* 非特权指令：用户程序可以使用的指令。举例：控制转移  算数运算  取数指令   访管指令（使用户程序从用户态陷入内核态）

### 特权级别：
**特权环：R0, R1, R2, R3**。R0相当于核心态，R3相当于用户态；不同级别能够运行不同的指令集合；

 ### CPU之间的转换
 * 用户态--->核心态：唯一途径是通过中断、异常、陷入机制（访管指令）
* 核心态--->用户态：设置程序状态字PSW
### **核心态和用户态的区别**
* 核心态与用户态是操作系统的两种运行级别，当**程序运行在3级特权级上时，就可以称之为运行在用户态**。因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；当**程序运行在0级特权级上时，就可以称之为运行在内核态**。

* 运行在**用户态下的程序不能直接访问操作系统内核数据结构和程序**。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。
* **主要差别**：处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理机是可被抢占的 ；而处于核心态执行中的进程，则能访问所有的内存空间和对象，且所占有的处理机是不允许被抢占的。

### **核心态到用户态的转换**
以下3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。

* 系统调用：这是用户态进程主动要求切换到核心态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。

* 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了核心态，比如缺页异常。
* 外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。