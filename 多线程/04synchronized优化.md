# JVM虚拟机对synchronized锁的优化
<br><img src=img/各种锁.png><br>
## 线程切换的代价
**监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现**的，而**操作系统实现线程之间的切换时需要从用户态转换到核心态**，这个状态之间的转换需要相对比较长的时间，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。

这种依赖于Mutex Lock实现的锁机制也被称为“重量级锁”。频繁的通过Synchronized实现同步会严重影响到程序效率，为了减少重量级锁带来的性能开销，JDK对Synchronized进行了种种优化。

Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了**轻量级锁和偏向锁**，还引入了自适应的自旋锁，并默认开启。其中，偏向锁、轻量级锁和自旋锁属于乐观锁，重量级锁属于悲观锁。锁的状态总共有四种，**无锁状态、偏向锁、轻量级锁和重量级锁**。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说**只能从低到高升级，不会出现锁的降级**。

# 使用新锁的优化
## 偏向锁
偏向锁是一种针对加锁的优化手段。在大多数情况下，锁不仅不存在多线程竞争，而且总是由一个线程多次获得，因此为了**减少同一线程获取锁的代价而引入偏向锁**。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提高程序的性能。

**获取锁**：
1. 检测Mark Word是否为可偏向锁，即是否为偏向锁为1，锁标识位为01；

2. 若是可偏向锁，则测试线程ID是否为当前线程ID，如果是，则执行步骤5，否则执行步骤3；
3. 如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程4；
4. 通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；
5. 执行同步代码块

**释放锁**：
1. 有其他线程来获取这个锁，偏向锁的释放采用了一种**只有竞争才会释放锁**的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。
2. 等待**全局安全点**(在这个是时间点上没有字节码正在执行)。
3. 暂停拥有偏向锁的线程，检查持有偏向锁的线程是否活着，如果不处于活动状态，则将对象头设置为**无锁状态**，否则设置为被**锁定状态**。如果锁对象处于**无锁状态，则恢复到无锁状态(01)**，以允许其他线程竞争，如果锁对象处于**锁定状态，则挂起持有偏向锁的线程，并将对象头Mark Word的锁记录指针改成当前线程的锁记录，锁升级为轻量级锁状态(00)**。

<br><img src=img/偏向锁.png><br>
偏向锁的释放过程：
<br><img src=img/偏向锁的释放.png><br>

对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。

## 轻量级锁
轻量锁是基于对象头中的Mark Word实现的锁，引入轻量级锁的主要目的是在**没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗**。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。轻量级锁所适应的场景是**线程交替执行同步块的场合**，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。

**获取锁**：
1. 在线程进入同步方法、同步块的时候，如果**同步对象锁状态为无锁状态**(锁标志位为"01"状态，是否为偏向锁为"0")，虚拟机首先将在**当前线程的栈帧中建立一个名为锁记录(Lock Recored)的空间**，用于储存锁**对象目前的Mark Word的拷贝**(官方把这份拷贝加了个Displaced前缀，即Displaced Mark Word)；如果同步对象锁不是无锁状态，则执行5。

2. 将对象头的Mark Word拷贝到线程的锁记录(Lock Recored)中。
3. 拷贝成功后，虚拟机将使用CAS操作尝试**将对象的Mark Word更新为指向Lock Record的指针**。如果这个更新成功了，则执行步骤4，否则执行步骤5。
4. **更新成功**，这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为"00"，即表示此对象**处于轻量级锁的状态**。
5. 更新失败，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行，否则说明这个锁对象已经被其它线程抢占了。进行自旋，如果自旋结束仍然没有获得锁，轻量级锁就需要膨胀为重量级锁，锁标志位状态值变为"10"，Mark Word中储存就是指向monitor对象的指针，当前线程以及后面等待锁的线程也要进入阻塞状态。

**释放锁**：
1. 使用CAS操作将对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来(依据Mark Word中锁记录指针是否还指向本线程的锁记录)，如果替换成功，则执行步骤2，否则执行步骤3。

2. 如果替换成功，整个同步过程就完成了，恢复到无锁的状态(01)。
3. 如果替换失败，说明有其他线程尝试获取该锁(此时锁已膨胀)，那就要在释放锁的同时，唤醒被挂起的线程。

<br><img src=img/轻量锁.png><br>

## 自旋锁
轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，**线程持有锁的时间都不会太长**，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会**让当前想要获取锁的线程做几个空循环，等待一段时间**(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起。

如果持有锁的线程很快释放了锁，那么自旋锁的效率就非常高，但是反之，自旋的线程会拜拜浪费掉处理的资源，这样会带来性能上的浪费，所以说，自旋的次数应该有一个限制，如果超过了定义的时间还没有获取到锁，那么应该被挂起。自旋锁在jdk1.4被引入，默认关闭，默认旋转次数为10次，在jdk1.6中默认开启自旋锁，同时引入**自适应的自旋锁**，让虚拟机自行调整自旋次数。

## 自适应自旋锁
JDK 1.6引入了适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由**前一次在同一个锁上的自旋时间及锁的拥有者的状态**来决定。线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。


## 锁消除
Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过**对运行上下文的扫描，去除不可能存在共享资源竞争的锁**。如StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。

## 锁粗化
在使用锁的时候，需要让同步块的作用范围尽可能小，这样做的目的是**为了使需要同步的操作数量尽可能小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁**。



# 锁的膨胀流程
在前面偏向锁和轻量级锁的小节中已经大概了解的锁的膨胀流程：

**偏向锁->轻量级锁->重量级锁**，偏向锁，轻量级锁都是乐观锁，重量级锁是悲观锁。

1. 一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。

2. 一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象是偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。

3. 轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。
<br><img src=img/锁转换过程.png><br>
<br><img src=img/锁膨胀流程.png><br>


## 对象头变为锁后hashcode的存储
在无锁状态下，对象的hashcode存储在对象的对象头中，但是一旦对象加上偏向锁，那么对象头中的信息就会变为锁信息，没有额外的空间存储hashcode，其中的规则为：
1. 如果一个对象已经计算过identity hashcode，它就无法进入偏向锁状态；（mark word里没地方同时放bias信息和identity hashcode）
2. 当一个对象当前正处于偏向锁状态，并且需要计算其identity hashcode的话，则它的偏向锁会被撤销，并且锁会膨胀为重量锁；
3. 重量锁的实现中，ObjectMonitor类里有字段可以记录非加锁状态下的mark word，其中可以存储identity hashcode的值。或者简单说就是重量锁可以存下identity hashcode。

这个的hashcode只针对identity hashcode，指的是未被重写的java.lang.Object.hashCode()返回的值，而不是用户自定义hashcode返回的值。

因为mark word里没地方同时放bias信息和identity hashcode，所以计算过identity hashcode之后的对象无法进入偏向锁。
HotSpot VM是假定“实际上只有很少对象会计算identity hashcode”来做优化的；换句话说如果实际上有很多对象都计算了identity hashcode的话，HotSpot VM会被迫使用比较不优化的模式。