## Java内存模型(Java Memory Model，JMM)
计算机在执行过程中，每条**指令都是在CPU中执行的**，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时**数据是存放在主存（物理内存）当中的**，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此**在CPU里面就有了高速缓存**。

也就是，当程序在运行过程中，会**将运算需要的数据从主存复制一份到CPU的高速缓存当中**，那么CPU进行计算时就可以直接**从它的高速缓存读取数据和向其中写入数据**，当运算结束之后，**再将高速缓存中的数据刷新到主存当中**。例如
```
i = i+1;
```
当线程执行这个语句时，会先从内存中读取i的值，然后复制一份到高速缓存中，然后CPU执行指令进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存中。

这个代码在单线程中运行是没有问题的，但是在多线程中运行就会有问题了，在多核CPU中，每条线程可能运行于不同的CPU中，因此每条线程都有自己的高速缓存。如果初始两条线程都读取i的值为1到自己的高速缓存中，然后线程1进行+1操作，写入高速缓存后刷新到内存，然后线程2也进行相同的操作，那么i的值就为1，这就是缓存一致性问题。通常这种被多个线程访问的变量称为**共享变量**。

**JMM**：Java虚拟机中试图定义一种Java内存模型(JMM)来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。Java内存模型规定所有的变量都是存在**主存**当中（类似于前面说的物理内存），每个线程都有自己的**工作内存**（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存，线程之间无法相互直接访问，变量传递均需要通过主存完成。

1. 每个线程都有自己的本地内存空间（Java栈中的帧），线程执行时，**先把变量从内存读取到线程自己的本地空间，然后对该变量进行操作**。
2. 对该变量**操作完成以后，在某个时间把变量重新刷新回主内存**。
<br><img src=img/Java内存.png><br>

## 并发编程中的三个概念
* **原子性**：一个操作或者多个操作，要么**全部执行并且在执行过程中不被打断**，要么就不执行。通过synchronized和Lock可以实现原子性。
* **可见性**：**一个线程修改了变量，其他线程可以立刻看得到修改后的值**。保证可见性的方法：volatile、synchronized、Lock。
* **有序性**：程序执行的顺序按照代码的先后顺序执行。JVM在运行程序时，不一定会按照Java中代码的顺序来执行，可能会发生**指令重排序**。指令重排序是指处理器为了提高程序运行效率，对输入的代码进行优化，**它不保证程序中的各个语句的先后执行顺序同代码中的一致，但是他会保证最终执行的结果是一致的**。指令重排序不会影响单线程的执行，但是会影响多线程并发执行的正确性。可以使用volatile、synchronized、Lock来保证有序性。
    ```java
    int a = 10;    //语句1
    int r = 2;    //语句2
    a = a + 3;    //语句3
    r = a*a;     //语句4

    上面的代码一个可能的执行顺序是：2-1-3-4
    其中，语句1和语句2的执行顺序对结果没有影响，所以可以发生指令重排序。但是语句3和语句4就不可以，因为指令重排序会考虑指令之间的数据依赖性，如果一个指令A必须用到另一个执行B的结果，那么处理器会保证执行B在指令A之前运行，所以单线程情况下不会出现错误。

    //线程1:
    context = loadContext();   //语句1
    inited = true;             //语句2
 
    //线程2:
    while(!inited ){
        sleep()
    }
    doSomethingwithconfig(context);
    线程1中，由于语句1和语句2没有数据依赖性，因此有可能发生重排序，加入先执行了语句2，那么线程2中就会跳出循环取执行doSomethingwithconfig()方法。
    ```

## 锁机制的问题
加锁，多线程为了防止竞争资源，即防止对同一资源进行并发操作。锁机制存在以下问题：
1. 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延迟，引起性能问题。
2. 一个线程持有锁会导致其他所有需要此锁的线程挂起。
3. 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。

## volatile
* 保证了不同线程对这个变量操作时的可见性，一个线程修改了某个变量的值，这个新值会立即刷新到主存中，并且设置其他线程工作内存中的该值的缓存无效，其他线程要使用这个值时必须重新从内存中获取。
* 禁止指令重排序。
    * 当程序执行到volatile的读或者写操作时，在该操作前面的操作肯定已经全部执行，后面的操作肯定还没有执行；
    * 在执行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放在其前面执行。

### volatile原理
Java代码转换为字节码运行时，有volatile关键字的代码某些指令前会多出一个lock前缀指令，lock前缀指令相当于一个内存屏障，会提供三个功能：
* 锁总线，其它CPU对内存的读写请求都会被阻塞，直到锁释放，不过实际后来的处理器都采用锁缓存替代锁总线，因为锁总线的开销比较大，锁总线期间其他CPU没法访问内存
* lock后的写操作会回写已修改的数据，同时让其它CPU相关缓存行失效，从而重新从主存中加载最新的数据
* 不是内存屏障却能完成类似内存屏障的功能，阻止屏障两边的指令重排序